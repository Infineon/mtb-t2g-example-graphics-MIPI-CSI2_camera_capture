/**********************************************************************************************************************
 * \file cy_gfx_env.c
 * \copyright Copyright (C) Infineon Technologies AG 2025
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*****************************************************************************
* Include files
*****************************************************************************/
#include "cycfg_peripherals.h"
#include "cy_retarget_io.h"
#include "cy_gfx_env.h"
#include "mtb_hal.h"

#if defined(__cplusplus)
extern "C" {
#endif

/*****************************************************************************
* Local pre-processor symbols/macros ('define')
*****************************************************************************/
/* Clokc related macros */

#define DISP0_CLK_PLL_MIN_HZ                      110000000UL
#define DISP0_CLK_PLL_MAX_HZ                      220000000UL
#define DISP1_CLK_PLL_MIN_HZ                      110000000UL
#define DISP1_CLK_PLL_MAX_HZ                      200000000UL  /* 220 max if a PLL400M would be used*/

#define VIDEOSS_FIXED_DISP_CLK_DIV                2  /* Fixed "divide-by-2" in the display clock path*/
#define CLK_PATH_DISP0_CLK                        5  /* PLL400M #4*/
#define CLK_PATH_DISP1_CLK                        8  /* PLL200M #2*/
#define CLK_PATH_SMIF_CLK                         3  /* PLL400M #2*/
#define CLK_DIV_TO_REG_VAL(div)                   (((div) == 8) ? 3 : ((div) == 4) ? 2 : ((div) == 2) ? 1 : 0)

/* Macros needed to generate the VIDEOSS TCON mapping values */ 

#define R(bit)                                    ((bit) +  0)
#define G(bit)                                    ((bit) +  8)
#define B(bit)                                    ((bit) + 16)
#define HSYNC                                     (24)
#define VSYNC                                     (25)
#define DEN                                       (26)
#define RES                                       (27)
#define MAP_VALUE(n0,n1,n2,n3)                    (((n3)<<24) + ((n2)<<16) + ((n1)<<8) +(n0))

#define MAP_INDEX_JEIDA                           0
#define MAP_INDEX_VESA                            1

#define MAP_LVDS_CH_1_CFG_0                       0
#define MAP_LVDS_CH_1_CFG_1                       1
#define MAP_LVDS_CH_DUAL_CFG_0                    16

/* SMIF and HyperBus related macros */

#define GFXENV_SMIF_TIMEOUT                       1000
#define GFXENV_S27K_INITIAL_LATENCY               CY_SMIF_HB_LC7
#define GFXENV_S27K_MAX_CS_LOW_NS                 1000UL          /* t_CMS in nanoseconds*/

#define GFXENV_SMIF_MDL_TAP_XSPI400               6
#define GFXENV_SMIF_MDL_TAP_XSPI333               6
#define GFXENV_SMIF_MDL_TAP_XSPI266               6
#define GFXENV_SMIF_MDL_TAP_XSPI200               6

#define GFXENV_SMIF_SDL_TAP_XSPI400               0
#define GFXENV_SMIF_SDL_TAP_XSPI333               0
#define GFXENV_SMIF_SDL_TAP_XSPI266               1
#define GFXENV_SMIF_SDL_TAP_XSPI200               2

#define GFXENV_SMIF_GET_DLL_DIVIDER_FROM_ENUM(enum_val)    ((enum_val == 0) ? 2 : (enum_val == 1) ? 4 : (enum_val == 2) ? 8 : 16)
#define GFXENV_SMIF_GET_DLL_ENUM_FROM_DIVIDER(div_val)     ((div_val == 2) ? CY_SMIF_MDL_CLK_OUT_DIV2 : (div_val == 4) ? CY_SMIF_MDL_CLK_OUT_DIV4 : (div_val == 8) ? CY_SMIF_MDL_CLK_OUT_DIV8 : CY_SMIF_MDL_CLK_OUT_DIV16)

/*****************************************************************************
* Global variable definitions (declared in header file with 'extern')
*****************************************************************************/
/* For the Retarget -IO (Debug UART) usage */
static cy_stc_scb_uart_context_t    UART_context;           /* UART context */
static mtb_hal_uart_t               UART_hal_obj;           /* Debug UART HAL object  */
uint32_t counterTick = 0;

/* The definition for Power Enble */ 
#define PD_BASE                                 0x40B00000UL
#define PD_CTL_PWR_MODE_Msk                     0x3UL
#define PD_STATUS_PWR_DONE_Msk                  0x10UL

/*****************************************************************************
* Local type definitions ('typedef')
*****************************************************************************/

/*****************************************************************************
 ** \brief Port pin group enumeration type
 *****************************************************************************/
typedef enum
{
    Display0,
    Display1,
    Capture0,
    Smif0,
    Smif1,
    BlDisp0,
    BlDisp1,
    BlFpd0,
    BlFpd1,
    Button,
} en_portpin_group_t;


/*****************************************************************************
 ** \brief Port pin configuration type
 *****************************************************************************/
typedef struct
{
    en_portpin_group_t          enGroup;
    GPIO_PRT_Type*              pstcPort;
    uint8_t                     u8Pin;
    en_hsiom_sel_t              enMuxCfg;
    uint8_t                     u8DriveMode;
    uint8_t                     u8GpioOutVal;
} stc_portpin_cfg_t;

/*****************************************************************************
 ** \brief Display presets type
 *****************************************************************************/
typedef struct
{
    uint16_t  u16HorizontalActive;
    uint16_t  u16HorizontalTotal;
    uint16_t  u16VerticalActive;
    uint16_t  u16VerticalTotal;
    uint8_t   u8RefreshRateHz;
    bool      bUseFpd;
    uint8_t   u8MapIndex;
} stc_display_presets_t;

/*****************************************************************************
* Local variable definitions ('static')
*****************************************************************************/

/*****************************************************************************
 ** \brief Display presets
 *****************************************************************************/

static const stc_display_presets_t m_astcCustomDispPresets[] =
{   
    { 0 }, // dummy for "CY_GFXENV_DISP_TYPE_NONE_HDMI"
    { .u16HorizontalActive =  800, .u16HorizontalTotal =  992, .u16VerticalActive = 480, .u16VerticalTotal = 500, .u8RefreshRateHz = 60, .bUseFpd = true, .u8MapIndex = MAP_LVDS_CH_1_CFG_1     },      /* CY_GFXENV_DISP_TYPE_DEFAULT_CEA_VESA */
    { .u16HorizontalActive =  640, .u16HorizontalTotal =  800, .u16VerticalActive = 480, .u16VerticalTotal = 500, .u8RefreshRateHz = 60, .bUseFpd = true, .u8MapIndex = MAP_LVDS_CH_1_CFG_1     },      /* CY_GFXENV_DISP_TYPE_640_480_60_CEA_VESA */
    { .u16HorizontalActive = 1280, .u16HorizontalTotal = 1650, .u16VerticalActive = 720, .u16VerticalTotal = 750, .u8RefreshRateHz = 60, .bUseFpd = true, .u8MapIndex = MAP_LVDS_CH_1_CFG_1     },      /* CY_GFXENV_DISP_TYPE_1280_720_60_CEA_VESA */
    { .u16HorizontalActive = 1440, .u16HorizontalTotal = 1716, .u16VerticalActive = 480, .u16VerticalTotal = 525, .u8RefreshRateHz = 60, .bUseFpd = true, .u8MapIndex = MAP_LVDS_CH_DUAL_CFG_0  },      /* CY_GFXENV_DISP_TYPE_1440_480_60_CEA_VESA */
    { .u16HorizontalActive = 1920, .u16HorizontalTotal = 2200, .u16VerticalActive =1080, .u16VerticalTotal =1125, .u8RefreshRateHz = 60, .bUseFpd = true, .u8MapIndex = MAP_LVDS_CH_DUAL_CFG_0  },      /* CY_GFXENV_DISP_TYPE_1920_1080_60_CEA_VESA */
    { .u16HorizontalActive =  800, .u16HorizontalTotal = 1056, .u16VerticalActive = 480, .u16VerticalTotal = 535, .u8RefreshRateHz = 60, .bUseFpd = true, .u8MapIndex = MAP_LVDS_CH_1_CFG_1     },      /* CY_GFXENV_DISP_TYPE_800_480_60_HDMI_VESA */
    { .u16HorizontalActive =  720, .u16HorizontalTotal = 1000, .u16VerticalActive = 720, .u16VerticalTotal = 760, .u8RefreshRateHz = 78, .bUseFpd = true, .u8MapIndex = MAP_LVDS_CH_1_CFG_1     },      /* CY_GFXENV_DISP_TYPE_720_720_60_HDMI_VESA */
    { .u16HorizontalActive = 1024, .u16HorizontalTotal = 1344, .u16VerticalActive = 600, .u16VerticalTotal = 625, .u8RefreshRateHz = 60, .bUseFpd = true, .u8MapIndex = MAP_LVDS_CH_1_CFG_1     },      /* CY_GFXENV_DISP_TYPE_1024_600_60_HDMI_VESA */
    { .u16HorizontalActive = 1280, .u16HorizontalTotal = 1650, .u16VerticalActive = 720, .u16VerticalTotal = 750, .u8RefreshRateHz = 60, .bUseFpd = true, .u8MapIndex = MAP_LVDS_CH_1_CFG_1     },      /* CY_GFXENV_DISP_TYPE_1280_720_60_HDMI_VESA */
    { .u16HorizontalActive = 1600, .u16HorizontalTotal = 1760, .u16VerticalActive = 600, .u16VerticalTotal = 630, .u8RefreshRateHz = 60, .bUseFpd = true, .u8MapIndex = MAP_LVDS_CH_DUAL_CFG_0  },      /* CY_GFXENV_DISP_TYPE_1600_600_60_HDMI_VESA */
    { .u16HorizontalActive = 1920, .u16HorizontalTotal = 2180, .u16VerticalActive = 720, .u16VerticalTotal = 756, .u8RefreshRateHz = 60, .bUseFpd = true, .u8MapIndex = MAP_LVDS_CH_DUAL_CFG_0  },      /* CY_GFXENV_DISP_TYPE_1920_720_60_HDMI_VESA */
    { .u16HorizontalActive = 1920, .u16HorizontalTotal = 2200, .u16VerticalActive =1080, .u16VerticalTotal =1125, .u8RefreshRateHz = 60, .bUseFpd = true, .u8MapIndex = MAP_LVDS_CH_DUAL_CFG_0  },      /* CY_GFXENV_DISP_TYPE_1920_1080_60_HDMI_VESA */
};
/*****************************************************************************
 ** \brief FPD/LVDS Signal Mapping
 *****************************************************************************/
static const uint32_t m_aau32FpdMapping[7][2] =
{
//                    JEIDA standard                             VESA standard
//                +0     +1     +2     +3                    +0     +1     +2     +3
    { MAP_VALUE( G(2),  R(7),  R(6),  R(5)  ),   MAP_VALUE( G(0),  R(5),  R(4),  R(3)  ) },  // <-- Value for register MAPBIT3_0
    { MAP_VALUE( R(4),  R(3),  R(2),  B(3)  ),   MAP_VALUE( R(2),  R(1),  R(0),  B(1)  ) },  // <-- Value for register MAPBIT7_4
    { MAP_VALUE( B(2),  G(7),  G(6),  G(5)  ),   MAP_VALUE( B(0),  G(5),  G(4),  G(3)  ) },  // <-- Value for register MAPBIT11_8
    { MAP_VALUE( G(4),  G(3),  DEN,   VSYNC ),   MAP_VALUE( G(2),  G(1),  DEN,   VSYNC ) },  // <-- Value for register MAPBIT15_12
    { MAP_VALUE( HSYNC, B(7),  B(6),  B(5)  ),   MAP_VALUE( HSYNC, B(5),  B(4),  B(3)  ) },  // <-- Value for register MAPBIT19_16
    { MAP_VALUE( B(4),  RES,   B(1),  B(0)  ),   MAP_VALUE( B(2),  RES,   B(7),  B(6)  ) },  // <-- Value for register MAPBIT23_20
    { MAP_VALUE( G(1),  G(0),  R(1),  R(0)  ),   MAP_VALUE( G(7),  G(6),  R(7),  R(6)  ) },  // <-- Value for register MAPBIT27_24
};

/*****************************************************************************
 ** \brief Port pin configuration
 *****************************************************************************/
static const stc_portpin_cfg_t m_astcPortPinCfg[] =
{
#ifdef CY_BSP_HDR_DISP0_TTL_AVAILABLE
    { .enGroup = Display0, .pstcPort = CY_DISP0_CLK_PORT,        .u8Pin = CY_DISP0_CLK_PIN,        .enMuxCfg = CY_DISP0_CLK_PIN_MUX,        .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_CTRL0_PORT,      .u8Pin = CY_DISP0_CTRL0_PIN,      .enMuxCfg = CY_DISP0_CTRL0_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_CTRL1_PORT,      .u8Pin = CY_DISP0_CTRL1_PIN,      .enMuxCfg = CY_DISP0_CTRL1_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_CTRL2_PORT,      .u8Pin = CY_DISP0_CTRL2_PIN,      .enMuxCfg = CY_DISP0_CTRL2_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A0_0_PORT,  .u8Pin = CY_DISP0_DATA_A0_0_PIN,  .enMuxCfg = CY_DISP0_DATA_A0_0_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A0_1_PORT,  .u8Pin = CY_DISP0_DATA_A0_1_PIN,  .enMuxCfg = CY_DISP0_DATA_A0_1_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A0_2_PORT,  .u8Pin = CY_DISP0_DATA_A0_2_PIN,  .enMuxCfg = CY_DISP0_DATA_A0_2_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A0_3_PORT,  .u8Pin = CY_DISP0_DATA_A0_3_PIN,  .enMuxCfg = CY_DISP0_DATA_A0_3_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A0_4_PORT,  .u8Pin = CY_DISP0_DATA_A0_4_PIN,  .enMuxCfg = CY_DISP0_DATA_A0_4_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A0_5_PORT,  .u8Pin = CY_DISP0_DATA_A0_5_PIN,  .enMuxCfg = CY_DISP0_DATA_A0_5_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A0_6_PORT,  .u8Pin = CY_DISP0_DATA_A0_6_PIN,  .enMuxCfg = CY_DISP0_DATA_A0_6_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A0_7_PORT,  .u8Pin = CY_DISP0_DATA_A0_7_PIN,  .enMuxCfg = CY_DISP0_DATA_A0_7_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A0_8_PORT,  .u8Pin = CY_DISP0_DATA_A0_8_PIN,  .enMuxCfg = CY_DISP0_DATA_A0_8_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A0_9_PORT,  .u8Pin = CY_DISP0_DATA_A0_9_PIN,  .enMuxCfg = CY_DISP0_DATA_A0_9_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A0_10_PORT, .u8Pin = CY_DISP0_DATA_A0_10_PIN, .enMuxCfg = CY_DISP0_DATA_A0_10_PIN_MUX, .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A0_11_PORT, .u8Pin = CY_DISP0_DATA_A0_11_PIN, .enMuxCfg = CY_DISP0_DATA_A0_11_PIN_MUX, .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A1_0_PORT,  .u8Pin = CY_DISP0_DATA_A1_0_PIN,  .enMuxCfg = CY_DISP0_DATA_A1_0_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A1_1_PORT,  .u8Pin = CY_DISP0_DATA_A1_1_PIN,  .enMuxCfg = CY_DISP0_DATA_A1_1_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A1_2_PORT,  .u8Pin = CY_DISP0_DATA_A1_2_PIN,  .enMuxCfg = CY_DISP0_DATA_A1_2_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A1_3_PORT,  .u8Pin = CY_DISP0_DATA_A1_3_PIN,  .enMuxCfg = CY_DISP0_DATA_A1_3_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A1_4_PORT,  .u8Pin = CY_DISP0_DATA_A1_4_PIN,  .enMuxCfg = CY_DISP0_DATA_A1_4_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A1_5_PORT,  .u8Pin = CY_DISP0_DATA_A1_5_PIN,  .enMuxCfg = CY_DISP0_DATA_A1_5_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A1_6_PORT,  .u8Pin = CY_DISP0_DATA_A1_6_PIN,  .enMuxCfg = CY_DISP0_DATA_A1_6_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A1_7_PORT,  .u8Pin = CY_DISP0_DATA_A1_7_PIN,  .enMuxCfg = CY_DISP0_DATA_A1_7_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A1_8_PORT,  .u8Pin = CY_DISP0_DATA_A1_8_PIN,  .enMuxCfg = CY_DISP0_DATA_A1_8_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A1_9_PORT,  .u8Pin = CY_DISP0_DATA_A1_9_PIN,  .enMuxCfg = CY_DISP0_DATA_A1_9_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A1_10_PORT, .u8Pin = CY_DISP0_DATA_A1_10_PIN, .enMuxCfg = CY_DISP0_DATA_A1_10_PIN_MUX, .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A1_11_PORT, .u8Pin = CY_DISP0_DATA_A1_11_PIN, .enMuxCfg = CY_DISP0_DATA_A1_11_PIN_MUX, .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
#endif

#ifdef CY_BSP_HDR_DISP1_TTL_AVAILABLE
    { .enGroup = Display1, .pstcPort = CY_DISP1_CLK_PORT,        .u8Pin = CY_DISP1_CLK_PIN,        .enMuxCfg = CY_DISP1_CLK_PIN_MUX,        .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_CTRL0_PORT,      .u8Pin = CY_DISP1_CTRL0_PIN,      .enMuxCfg = CY_DISP1_CTRL0_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_CTRL1_PORT,      .u8Pin = CY_DISP1_CTRL1_PIN,      .enMuxCfg = CY_DISP1_CTRL1_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_CTRL2_PORT,      .u8Pin = CY_DISP1_CTRL2_PIN,      .enMuxCfg = CY_DISP1_CTRL2_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A0_0_PORT,  .u8Pin = CY_DISP1_DATA_A0_0_PIN,  .enMuxCfg = CY_DISP1_DATA_A0_0_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A0_1_PORT,  .u8Pin = CY_DISP1_DATA_A0_1_PIN,  .enMuxCfg = CY_DISP1_DATA_A0_1_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A0_2_PORT,  .u8Pin = CY_DISP1_DATA_A0_2_PIN,  .enMuxCfg = CY_DISP1_DATA_A0_2_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A0_3_PORT,  .u8Pin = CY_DISP1_DATA_A0_3_PIN,  .enMuxCfg = CY_DISP1_DATA_A0_3_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A0_4_PORT,  .u8Pin = CY_DISP1_DATA_A0_4_PIN,  .enMuxCfg = CY_DISP1_DATA_A0_4_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A0_5_PORT,  .u8Pin = CY_DISP1_DATA_A0_5_PIN,  .enMuxCfg = CY_DISP1_DATA_A0_5_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A0_6_PORT,  .u8Pin = CY_DISP1_DATA_A0_6_PIN,  .enMuxCfg = CY_DISP1_DATA_A0_6_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A0_7_PORT,  .u8Pin = CY_DISP1_DATA_A0_7_PIN,  .enMuxCfg = CY_DISP1_DATA_A0_7_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A0_8_PORT,  .u8Pin = CY_DISP1_DATA_A0_8_PIN,  .enMuxCfg = CY_DISP1_DATA_A0_8_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A0_9_PORT,  .u8Pin = CY_DISP1_DATA_A0_9_PIN,  .enMuxCfg = CY_DISP1_DATA_A0_9_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A0_10_PORT, .u8Pin = CY_DISP1_DATA_A0_10_PIN, .enMuxCfg = CY_DISP1_DATA_A0_10_PIN_MUX, .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A0_11_PORT, .u8Pin = CY_DISP1_DATA_A0_11_PIN, .enMuxCfg = CY_DISP1_DATA_A0_11_PIN_MUX, .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A1_0_PORT,  .u8Pin = CY_DISP1_DATA_A1_0_PIN,  .enMuxCfg = CY_DISP1_DATA_A1_0_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A1_1_PORT,  .u8Pin = CY_DISP1_DATA_A1_1_PIN,  .enMuxCfg = CY_DISP1_DATA_A1_1_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A1_2_PORT,  .u8Pin = CY_DISP1_DATA_A1_2_PIN,  .enMuxCfg = CY_DISP1_DATA_A1_2_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A1_3_PORT,  .u8Pin = CY_DISP1_DATA_A1_3_PIN,  .enMuxCfg = CY_DISP1_DATA_A1_3_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A1_4_PORT,  .u8Pin = CY_DISP1_DATA_A1_4_PIN,  .enMuxCfg = CY_DISP1_DATA_A1_4_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A1_5_PORT,  .u8Pin = CY_DISP1_DATA_A1_5_PIN,  .enMuxCfg = CY_DISP1_DATA_A1_5_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A1_6_PORT,  .u8Pin = CY_DISP1_DATA_A1_6_PIN,  .enMuxCfg = CY_DISP1_DATA_A1_6_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A1_7_PORT,  .u8Pin = CY_DISP1_DATA_A1_7_PIN,  .enMuxCfg = CY_DISP1_DATA_A1_7_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A1_8_PORT,  .u8Pin = CY_DISP1_DATA_A1_8_PIN,  .enMuxCfg = CY_DISP1_DATA_A1_8_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A1_9_PORT,  .u8Pin = CY_DISP1_DATA_A1_9_PIN,  .enMuxCfg = CY_DISP1_DATA_A1_9_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A1_10_PORT, .u8Pin = CY_DISP1_DATA_A1_10_PIN, .enMuxCfg = CY_DISP1_DATA_A1_10_PIN_MUX, .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A1_11_PORT, .u8Pin = CY_DISP1_DATA_A1_11_PIN, .enMuxCfg = CY_DISP1_DATA_A1_11_PIN_MUX, .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
#endif

#ifdef CY_BSP_HDR_CAP0_TTL_AVAILABLE
    { .enGroup = Capture0, .pstcPort = CY_CAP0_CLK_PORT,         .u8Pin = CY_CAP0_CLK_PIN,         .enMuxCfg = CY_CAP0_CLK_PIN_MUX,         .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA0_PORT,       .u8Pin = CY_CAP0_DATA0_PIN,       .enMuxCfg = CY_CAP0_DATA0_PIN_MUX,       .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA1_PORT,       .u8Pin = CY_CAP0_DATA1_PIN,       .enMuxCfg = CY_CAP0_DATA1_PIN_MUX,       .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA2_PORT,       .u8Pin = CY_CAP0_DATA2_PIN,       .enMuxCfg = CY_CAP0_DATA2_PIN_MUX,       .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA3_PORT,       .u8Pin = CY_CAP0_DATA3_PIN,       .enMuxCfg = CY_CAP0_DATA3_PIN_MUX,       .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA4_PORT,       .u8Pin = CY_CAP0_DATA4_PIN,       .enMuxCfg = CY_CAP0_DATA4_PIN_MUX,       .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA5_PORT,       .u8Pin = CY_CAP0_DATA5_PIN,       .enMuxCfg = CY_CAP0_DATA5_PIN_MUX,       .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA6_PORT,       .u8Pin = CY_CAP0_DATA6_PIN,       .enMuxCfg = CY_CAP0_DATA6_PIN_MUX,       .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA7_PORT,       .u8Pin = CY_CAP0_DATA7_PIN,       .enMuxCfg = CY_CAP0_DATA7_PIN_MUX,       .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA8_PORT,       .u8Pin = CY_CAP0_DATA8_PIN,       .enMuxCfg = CY_CAP0_DATA8_PIN_MUX,       .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA9_PORT,       .u8Pin = CY_CAP0_DATA9_PIN,       .enMuxCfg = CY_CAP0_DATA9_PIN_MUX,       .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA10_PORT,      .u8Pin = CY_CAP0_DATA10_PIN,      .enMuxCfg = CY_CAP0_DATA10_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA11_PORT,      .u8Pin = CY_CAP0_DATA11_PIN,      .enMuxCfg = CY_CAP0_DATA11_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA12_PORT,      .u8Pin = CY_CAP0_DATA12_PIN,      .enMuxCfg = CY_CAP0_DATA12_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA13_PORT,      .u8Pin = CY_CAP0_DATA13_PIN,      .enMuxCfg = CY_CAP0_DATA13_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA14_PORT,      .u8Pin = CY_CAP0_DATA14_PIN,      .enMuxCfg = CY_CAP0_DATA14_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA15_PORT,      .u8Pin = CY_CAP0_DATA15_PIN,      .enMuxCfg = CY_CAP0_DATA15_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA16_PORT,      .u8Pin = CY_CAP0_DATA16_PIN,      .enMuxCfg = CY_CAP0_DATA16_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA17_PORT,      .u8Pin = CY_CAP0_DATA17_PIN,      .enMuxCfg = CY_CAP0_DATA17_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA18_PORT,      .u8Pin = CY_CAP0_DATA18_PIN,      .enMuxCfg = CY_CAP0_DATA18_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA19_PORT,      .u8Pin = CY_CAP0_DATA19_PIN,      .enMuxCfg = CY_CAP0_DATA19_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA20_PORT,      .u8Pin = CY_CAP0_DATA20_PIN,      .enMuxCfg = CY_CAP0_DATA20_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA21_PORT,      .u8Pin = CY_CAP0_DATA21_PIN,      .enMuxCfg = CY_CAP0_DATA21_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA22_PORT,      .u8Pin = CY_CAP0_DATA22_PIN,      .enMuxCfg = CY_CAP0_DATA22_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA23_PORT,      .u8Pin = CY_CAP0_DATA23_PIN,      .enMuxCfg = CY_CAP0_DATA23_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA24_PORT,      .u8Pin = CY_CAP0_DATA24_PIN,      .enMuxCfg = CY_CAP0_DATA24_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA25_PORT,      .u8Pin = CY_CAP0_DATA25_PIN,      .enMuxCfg = CY_CAP0_DATA25_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA26_PORT,      .u8Pin = CY_CAP0_DATA26_PIN,      .enMuxCfg = CY_CAP0_DATA26_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
#endif

  #ifdef CY_BL_DISP0_EN_PORT
    { .enGroup = BlDisp0,  .pstcPort = CY_BL_DISP0_EN_PORT,      .u8Pin = CY_BL_DISP0_EN_PIN,      .enMuxCfg = CY_BL_DISP0_EN_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 1 },
  #endif
  #ifdef CY_BL_DISP0_PWM_PORT
    { .enGroup = BlDisp0,  .pstcPort = CY_BL_DISP0_PWM_PORT,     .u8Pin = CY_BL_DISP0_PWM_PIN,     .enMuxCfg = CY_BL_DISP0_PWM_PIN_MUX,     .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 1 },
  #endif
  #ifdef CY_FPDLINK0_BL_EN_PORT
    { .enGroup = BlFpd0,   .pstcPort = CY_FPDLINK0_BL_EN_PORT,   .u8Pin = CY_FPDLINK0_BL_EN_PIN,   .enMuxCfg = CY_FPDLINK0_BL_EN_PIN_MUX,   .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 1 },
  #endif
  #ifdef CY_FPDLINK0_BL_PWM_PORT
    { .enGroup = BlFpd0,   .pstcPort = CY_FPDLINK0_BL_PWM_PORT,  .u8Pin = CY_FPDLINK0_BL_PWM_PIN,  .enMuxCfg = CY_FPDLINK0_BL_PWM_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 1 },
  #endif

  #ifdef CY_BL_DISP1_EN_PORT
    { .enGroup = BlDisp1,  .pstcPort = CY_BL_DISP1_EN_PORT,      .u8Pin = CY_BL_DISP1_EN_PIN,      .enMuxCfg = CY_BL_DISP1_EN_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 1 }, 
  #endif
  #ifdef CY_BL_DISP1_PWM_PORT
    { .enGroup = BlDisp1,  .pstcPort = CY_BL_DISP1_PWM_PORT,     .u8Pin = CY_BL_DISP1_PWM_PIN,     .enMuxCfg = CY_BL_DISP1_PWM_PIN_MUX,     .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 1 },
  #endif
  #ifdef CY_FPDLINK1_BL_EN_PORT
    { .enGroup = BlFpd1,   .pstcPort = CY_FPDLINK1_BL_EN_PORT,   .u8Pin = CY_FPDLINK1_BL_EN_PIN,   .enMuxCfg = CY_FPDLINK1_BL_EN_PIN_MUX,   .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 1 },
  #endif
  #ifdef CY_FPDLINK1_BL_PWM_PORT
    { .enGroup = BlFpd1,   .pstcPort = CY_FPDLINK1_BL_PWM_PORT,  .u8Pin = CY_FPDLINK1_BL_PWM_PIN,  .enMuxCfg = CY_FPDLINK1_BL_PWM_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 1 },
  #endif

};

/*****************************************************************************
 ** \brief Hold GfxEnv driver internal config/status of all SMIFs and SMIF_DEVICEs
 *****************************************************************************/

/*****************************************************************************
* Local function prototypes ('static')
*****************************************************************************/
static void                  InitPortPins                   (const cy_gfxenv_stc_init_portpins_t * pstcPortInitCfg);

/*****************************************************************************
* Function implementation - global ('extern') and local ('static')
*****************************************************************************/

/*******************************************************************************
* Function Name: Cy_GfxEnv_Init
********************************************************************************
*
* \brief  Initializes the GFX environment
*
* \param  pstcGfxEnvCfg : The pointer to the init configuration struct
*
* \return cy_gfxenv_en_result_t
*
*******************************************************************************/
cy_gfxenv_en_result_t Cy_GfxEnv_Init(const cy_gfxenv_stc_cfg_t *pstcGfxEnvCfg)
{
    /* Initialize port pins if requested by user configuration*/
    if(pstcGfxEnvCfg->pstcInitPortPins != NULL)
    {
        InitPortPins(pstcGfxEnvCfg->pstcInitPortPins);
    }

    /*Initialize software timer module if requested by user configuration*/
    if(pstcGfxEnvCfg->bInitSwTimer != false)
    {
        /* Reset tick counter*/
        m_u64TickCountUs = 0;

        Cy_SysTick_Init(CY_SYSTICK_CLOCK_SOURCE_CLK_IMO, SYSTICK_RELOAD_VALUE);
        Cy_SysTick_SetCallback(0, NULL);
    }

    /* Initialize semihosting (low level I/O) together with required clock and port pin setup if requested by user configuration*/
    if(pstcGfxEnvCfg->bInitSemihosting != false)
    {
    
        /* Initialize retarget-io to use the debug UART port */
        Cy_SCB_UART_Init(UART_HW, &UART_config, &UART_context);
        Cy_SCB_UART_Enable(UART_HW);

        mtb_hal_uart_setup(&UART_hal_obj, &UART_hal_config, &UART_context, NULL);
        cy_retarget_io_init(&UART_hal_obj);
    }

    return CY_GFXENV_SUCCESS;
}


/*******************************************************************************
* Function Name: Cy_GfxEnv_FastInit
********************************************************************************
*
* \brief  Initializes the GFX environment with most commonly used settings.
*         Only a limited number of parameters can be configured, e.g.
*         whether SMIF instances and connected memories are initialized
*         because this would stuck execution if memory is not connected or in
*         case of signal problems.
*
* \warning u8Smif0ExtClockMhz and u8Smif1ExtClockMhz ratio needs to be 1, 2, 4 or 8 
*          (or 1, 0.5, 0.25, 0.125 respectively) at the moment, because by default
*          the SMIF HF clocks use the same source PLL and hence only the HF clock
*          dividers can be used
*
* \param  u8Smif0ExtClockMhz : SMIF0 external clock frequency,
*                              if value == 0, SMIF0 will not be initialized
* \param  u8Smif1ExtClockMhz : SMIF1 external clock frequency,
*                              if value == 0, SMIF1 will not be initialized
* \param  pfnButtonCallback  : Callback from button handler, can be NULL (then
*                              button driver and port pins are not initialized)
*
* \return cy_gfxenv_en_result_t
*
*******************************************************************************/
cy_gfxenv_en_result_t Cy_GfxEnv_FastInit(uint8_t u8Smif0ExtClockMhz, uint8_t u8Smif1ExtClockMhz, cy_button_callback_t pfnButtonCallback)
{
   cy_gfxenv_stc_cfg_t stcGfxEnvCfg =
    {
        .bInitSwTimer         = true,
        .bInitSemihosting     = true,
        .pstcInitPortPins     = &(cy_gfxenv_stc_init_portpins_t)
                                {
                                  #if (CY_USE_PSVP == 0)
                                    .bInitDisplay0Ttl       = false, // usually the FPD-Link is used on silicon
                                  #else
                                    .bInitDisplay0Ttl       = true,  // FPD-Link #0 is not available on PSVP
                                  #endif
                                  #if (CY_USE_PSVP == 0) && defined(VIDEOSS0_FPDLINK1)
                                    .bInitDisplay1Ttl       = true, // usually the FPD-Link is used on silicon (if it is available)
                                  #else
                                    .bInitDisplay1Ttl       = true,  // FPD-Link #1 is not available on PSVP or on silicon for this device
                                  #endif
                                    .bInitCapture0Ttl       = false,
                                    .bInitSmif0             = true,  // might be overriden by function parameter u8Smif0ExtClockMhz
                                    .bInitSmif1             = true,  // might be overriden by function parameter u8Smif1ExtClockMhz
                                    .bInitBacklightDisp0    = false, // backlights are enabled by jumper setting on CY boards, would only be needed for PWM dimming
                                    .bInitBacklightDisp1    = false, // backlights are enabled by jumper setting on CY boards, would only be needed for PWM dimming
                                    .bInitBacklightFpdLink0 = false, // backlights are enabled by jumper setting on CY boards, would only be needed for PWM dimming
                                    .bInitBacklightFpdLink1 = false, // backlights are enabled by jumper setting on CY boards, would only be needed for PWM dimming
                                    .bInitButtonGpios       = true,
                                },
        .pstcInitExtMem       = &(cy_gfxenv_stc_init_extmem_t)
                                {
                                    .bInitMpuTemporarily = true,
                                    .u8MpuRegionTemp     = CY_GFXENV_SMIF_TEMP_MPU_REGION,
                                    .apstcInitSmif       = {
                                                                &(cy_gfxenv_stc_smif_cfg_t)
                                                                {
                                                                    .u8SmifExtClockMhz = 0, // updated by function parameter
                                                                    .apstcDevUsrCfg    = {
                                                                                             &(cy_gfxenv_stc_smif_device_cfg_t)
                                                                                             {
                                                                                                 .u32BaseAddress           = CY_GFXENV_FASTINIT_EXTMEM_FLASH_BASE,
                                                                                                 .u16SizeMegaBytes         = 64,
                                                                                                 .enExtMemType             = CY_GFXENV_EXTMEM_TYPE_S28H,
                                                                                             },
                                                                                             NULL,
                                                                                         },
                                                                }, 
                                                                &(cy_gfxenv_stc_smif_cfg_t)
                                                                {
                                                                    .u8SmifExtClockMhz = 0, // updated by function parameter
                                                                    .apstcDevUsrCfg    = {
                                                                                             NULL,
                                                                                             &(cy_gfxenv_stc_smif_device_cfg_t)
                                                                                             {
                                                                                                 .u32BaseAddress           = CY_GFXENV_FASTINIT_EXTMEM_RAM_BASE,
                                                                                                 .u16SizeMegaBytes         = 8,
                                                                                                 .enExtMemType             = CY_GFXENV_EXTMEM_TYPE_S27KXXXX2,
                                                                                             },
                                                                                         },
                                                                },
                                                            },
                                },
        .pstcInitButtons      = &(cy_gfxenv_stc_init_buttons_t)
                                {
                                    .u8CySwTimerId = (CY_SWTMR_MAX_TIMERS - 1), // use last timer
                                    .pfnCallback   = NULL,
                                },

    };
    /* Disable SMIF clock, port and memory initialization if not requested by user, otherwise update the frequency with value from user*/
    if(u8Smif0ExtClockMhz == 0)
    {
        stcGfxEnvCfg.pstcInitPortPins->bInitSmif0 = false;
        stcGfxEnvCfg.pstcInitExtMem->apstcInitSmif[0] = NULL;
    }
    else
    {
        stcGfxEnvCfg.pstcInitExtMem->apstcInitSmif[0]->u8SmifExtClockMhz = u8Smif0ExtClockMhz;
    }
    if(u8Smif1ExtClockMhz == 0)
    {
        stcGfxEnvCfg.pstcInitPortPins->bInitSmif1 = false;
        stcGfxEnvCfg.pstcInitExtMem->apstcInitSmif[1] = NULL;
    }    
    else
    {
        stcGfxEnvCfg.pstcInitExtMem->apstcInitSmif[1]->u8SmifExtClockMhz = u8Smif1ExtClockMhz;
    }
    if((u8Smif0ExtClockMhz == 0) && (u8Smif1ExtClockMhz == 0))
    {
        stcGfxEnvCfg.pstcInitExtMem = NULL;
    }

    /* Disable button driver and corresponding port pin initialization if user does not provide callback*/
    if(pfnButtonCallback == NULL)
    {
        stcGfxEnvCfg.pstcInitButtons = NULL;
    }
    else
    {
        stcGfxEnvCfg.pstcInitButtons->pfnCallback = pfnButtonCallback;
    }

    return Cy_GfxEnv_Init(&stcGfxEnvCfg);
}

/*******************************************************************************
* Function Name: Cy_GfxEnv_EnableTestImage
********************************************************************************
*
* \brief  Enables the output of test images on the 2 display links.
*         Prior initialization (e.g. Cy_GfxEnv_Init or Cy_GfxEnv_FastInit APIs)
*         may be necessary before calling this function.
*
* \param  enDisp0Type : The display type to be setup for display link #0
* \param  enDisp1Type : The display type to be setup for display link #1
*
* \return cy_gfxenv_en_result_t
*
*******************************************************************************/

#define VIDEOSS_FIXED_DISP_CLK_DIV 2 // Fixed "divide-by-2" in the display clock path
#define CLK_DIV_TO_REG_VAL(div) (((div) == 8) ? 3 : ((div) == 4) ? 2 : ((div) == 2) ? 1 : 0)
#define CLK_PATH_DISP0_CLK 5  // PLL400M #4
#define CLK_PATH_DISP1_CLK 8  // PLL200M #2

void enableTestImage()
{
    uint8_t u8Disp1ClkPllDiv = 2;
    uint32_t Display0_CLK;
    uint32_t Display1_CLK;

  #ifdef CYREG_VIDEOSS0_VIDEOSSCFG_DSP0_CTL
    // Set global Enable bit for DSP0 domain
    VIDEOSS0_SUBSS0_VIDEOSSCFG->unDSP0_CTL.stcField.u1DSP0_ENABLED = 1;
  #endif
  #ifdef CYREG_VIDEOSS0_VIDEOSSCFG_DSP1_CTL
    // Set global Enable bit for DSP1 domain
    VIDEOSS0_SUBSS0_VIDEOSSCFG->unDSP1_CTL.stcField.u1DSP1_ENABLED = 1;
  #endif 
  
 
    Cy_SysClk_PllDisable(CLK_PATH_DISP1_CLK);
    Cy_SysClk_PllDisable(CLK_PATH_DISP0_CLK);

    cy_stc_pll_config_t stcPllCfg = {
        .inputFreq = 8000000,
        .outputFreq = 119040000,
        .outputMode = CY_SYSCLK_FLLPLL_OUTPUT_AUTO,
        .lfMode = false,
    };
    Cy_SysClk_PllConfigure(CLK_PATH_DISP1_CLK, &stcPllCfg);
    Cy_SysClk_PllEnable(CLK_PATH_DISP1_CLK, 10000);
    Display1_CLK = Cy_SysClk_PllGetFrequency(CLK_PATH_DISP1_CLK);
    
    Cy_SysClk_PllConfigure(CLK_PATH_DISP0_CLK, &stcPllCfg);
    Cy_SysClk_PllEnable(CLK_PATH_DISP0_CLK, 10000);
    Display0_CLK = Cy_SysClk_PllGetFrequency(CLK_PATH_DISP0_CLK);
   
    printf("Display0 Clock PLL Frequency: %lu\n",Display0_CLK);
    printf("Display1 Clock PLL Frequency: %lu\n",Display1_CLK);

    const uintptr_t videoSsBase = VIDEOSS0_BASE;
    const uint32_t clkDsp1CfgOffs = 0x00000014;

    typedef struct stc_VIDEOSS_VIDEOSSCFG_CLKDSP1CFG_field
    {
        uint32_t u2DIVVAL1 : 2;
        uint32_t : 2;
        uint32_t u1TTLCLKINV1 : 1;
        uint32_t : 27;
    } stc_VIDEOSS_VIDEOSSCFG_CLKDSP1CFG_field_t;

    volatile stc_VIDEOSS_VIDEOSSCFG_CLKDSP1CFG_field_t *clkDsp1CfgField
        = (volatile stc_VIDEOSS_VIDEOSSCFG_CLKDSP1CFG_field_t *) (videoSsBase + clkDsp1CfgOffs);

    clkDsp1CfgField->u2DIVVAL1 = CLK_DIV_TO_REG_VAL(u8Disp1ClkPllDiv);
    clkDsp1CfgField->u1TTLCLKINV1 = 0;

    const uint32_t frameGenBase = 0x40AA6000;
    const uint32_t htcfgOffs = 0x00000004;
    const uint32_t vtcfgOffs = 0x0000000C;
    const uint32_t fgEnableOffs = 0x00000064;

    typedef struct stc_VIDEOSS_FRAMEGEN_TCFG1_field
    {
        uint32_t u14ACT : 14;
        uint32_t : 2;
        uint32_t u14TOTAL : 14;
        uint32_t : 2;
    } stc_VIDEOSS_FRAMEGEN_TCFG1_field_t;

    volatile stc_VIDEOSS_FRAMEGEN_TCFG1_field_t *htcfgField
        = (volatile stc_VIDEOSS_FRAMEGEN_TCFG1_field_t *) (frameGenBase + htcfgOffs);
    volatile stc_VIDEOSS_FRAMEGEN_TCFG1_field_t *vtcfgField
        = (volatile stc_VIDEOSS_FRAMEGEN_TCFG1_field_t *) (frameGenBase + vtcfgOffs);

    htcfgField->u14ACT = 800;
    htcfgField->u14TOTAL = 992;
    vtcfgField->u14ACT = 480;
    vtcfgField->u14TOTAL = 500;
    *((volatile uint32_t *) (frameGenBase + fgEnableOffs)) |= 1;
}

/*******************************************************************************
* Function Name: Cy_GfxEnv_EnableHdmiTestImage
****************************************************************************//**
*
* \brief  Enables the output of test images on the display links.
*         Prior initialization (e.g. Cy_GfxEnv_Init or Cy_GfxEnv_FastInit APIs)
*         may be necessary before calling this function.
*
* \param  enDispType : The display resolution type, based on the resolution 
*         display link #1 or link #0&1 will be selected.
*
* \return cy_gfxenv_en_result_t
*
*******************************************************************************/
cy_gfxenv_en_result_t Cy_GfxEnv_EnableHdmiTestImage(cy_gfxenv_en_disp_custom_type_t enDispType)
{
    uint8_t u8DispSelConfig;
    uint8_t u8DispClkPllDiv;
    uint8_t u8DispClkPath;
    uint32_t u32DispPixelClkHz;
    uint32_t u32DispClkPllHz;
    uint32_t u32DispClkPllMax;
    bool bIsDispDualMode = false;

    cy_en_sysclk_status_t enSysClkRetVal;
    cy_gfxenv_en_result_t enRetVal = CY_GFXENV_SUCCESS;
    
    /* at least one display must be selected */
    if(enDispType == CY_GFXENV_DISP_TYPE_NONE_HDMI)
    {
        return CY_GFXENV_ERROR_BAD_PARAM;
    }

    /* Enable the display based on the selection */
    switch (enDispType)
    {
        case CY_GFXENV_DISP_TYPE_DEFAULT_CEA_VESA:
        case CY_GFXENV_DISP_TYPE_640_480_60_CEA_VESA:
        case CY_GFXENV_DISP_TYPE_1280_720_60_CEA_VESA:
        case CY_GFXENV_DISP_TYPE_800_480_60_HDMI_VESA:
        case CY_GFXENV_DISP_TYPE_720_720_60_HDMI_VESA:
        case CY_GFXENV_DISP_TYPE_1280_720_60_HDMI_VESA:
            u32DispClkPllMax = 200000000UL;
            u8DispSelConfig = MAP_LVDS_CH_1_CFG_0;
            VIDEOSS0_SUBSS0_VIDEOSSCFG->unDSP1_CTL.stcField.u1DSP1_ENABLED = 1;
            break;

        case CY_GFXENV_DISP_TYPE_1024_600_60_HDMI_VESA:
            u32DispClkPllMax = 220000000UL;
            u8DispSelConfig = MAP_LVDS_CH_1_CFG_1;
            VIDEOSS0_SUBSS0_VIDEOSSCFG->unDSP1_CTL.stcField.u1DSP1_ENABLED = 1;
            break;

        case CY_GFXENV_DISP_TYPE_1440_480_60_CEA_VESA:
        case CY_GFXENV_DISP_TYPE_1920_1080_60_CEA_VESA:
        case CY_GFXENV_DISP_TYPE_1600_600_60_HDMI_VESA:
        case CY_GFXENV_DISP_TYPE_1920_720_60_HDMI_VESA:
        case CY_GFXENV_DISP_TYPE_1920_1080_60_HDMI_VESA:
            u32DispClkPllMax = 200000000UL;
            u8DispSelConfig = MAP_LVDS_CH_DUAL_CFG_0;
            bIsDispDualMode = true;
            VIDEOSS0_SUBSS0_VIDEOSSCFG->unDSP0_CTL.stcField.u1DSP0_ENABLED = 1;
            //VIDEOSS0_SUBSS0_VIDEOSSCFG->unDSP1_CTL.stcField.u1DSP1_ENABLED = 1;
            break;

        default:
            /* Bad display selection */
            return CY_GFXENV_ERROR_BAD_PARAM;
            //break;
    }

    /* Get the pixel clock based on the resolution */
    u32DispPixelClkHz = (uint32_t) m_astcCustomDispPresets[enDispType].u16HorizontalTotal *
                                 (uint32_t) m_astcCustomDispPresets[enDispType].u16VerticalTotal *
                                 (uint32_t) m_astcCustomDispPresets[enDispType].u8RefreshRateHz;
                                 
   /* Pixel clock will get divided in dual fpd mode */
    if (bIsDispDualMode == true)
    {
        u32DispPixelClkHz = (u32DispPixelClkHz/2);
        
        /* Search the necessary PLL frequency and divider */
        for(u8DispClkPllDiv = 0; u8DispClkPllDiv <= 3; u8DispClkPllDiv++)
        {
            u32DispClkPllHz = u32DispPixelClkHz * (1 << u8DispClkPllDiv);
            if((u32DispClkPllHz >= DISP1_CLK_PLL_MIN_HZ) && (u32DispClkPllHz <= u32DispClkPllMax))
            {
                break;
            }
        }
        /* Check for the available pll dividers */
        if(u8DispClkPllDiv > 3)
        {
            return CY_GFXENV_ERROR_BAD_PARAM;
        }
    }
    else
    {
        /* Search the necessary PLL frequency and divider */
        for(u8DispClkPllDiv = 1; u8DispClkPllDiv <= 8; u8DispClkPllDiv *= 2)
        {
            u32DispClkPllHz = u32DispPixelClkHz * VIDEOSS_FIXED_DISP_CLK_DIV * u8DispClkPllDiv;
            if((u32DispClkPllHz >= DISP1_CLK_PLL_MIN_HZ) && (u32DispClkPllHz <= u32DispClkPllMax))
            {
                break;
            }
        }
        /* Check for the available pll dividers */
        if(u8DispClkPllDiv > 8)
        {
            return CY_GFXENV_ERROR_BAD_PARAM;
        }
    }

    /* Configure FPD1 with PLL200 */
    if (u8DispSelConfig == MAP_LVDS_CH_1_CFG_0)
    {
        u8DispClkPath = 8;
        enSysClkRetVal = Cy_SysClk_PllDisable(u8DispClkPath);
        CY_ASSERT(enSysClkRetVal == CY_SYSCLK_SUCCESS);
        //enSysClkRetVal = Cy_SysClk_GetPllInputFrequency(u8DispClkPath - 1, &dispPllInputFreq);
        Cy_SysClk_PllGetFrequency(u8DispClkPath);

        cy_stc_pll_config_t stcPllCfg =
        {
            .inputFreq    = 16000000UL,
            .outputFreq   = u32DispClkPllHz,
            .outputMode   = CY_SYSCLK_FLLPLL_OUTPUT_AUTO,
            .lfMode       = false,
        };
        enSysClkRetVal = Cy_SysClk_PllConfigure(u8DispClkPath, &stcPllCfg);
        CY_ASSERT(enSysClkRetVal == CY_SYSCLK_SUCCESS);
        enSysClkRetVal = Cy_SysClk_PllEnable(u8DispClkPath, 10000);
        CY_ASSERT(enSysClkRetVal == CY_SYSCLK_SUCCESS);
        Cy_SysClk_PllGetFrequency(u8DispClkPath);    
    }
    /* Configure FPD1 with PLL400, or in dual fpd mode */
    else if ((u8DispSelConfig == MAP_LVDS_CH_1_CFG_1) || (u8DispSelConfig == MAP_LVDS_CH_DUAL_CFG_0))
    {
        u8DispClkPath = 5; /* CY_SYSCLK_HFCLK_IN_CLKPATH5*/
        enSysClkRetVal = Cy_SysClk_Pll400MDisable(u8DispClkPath);
        CY_ASSERT(enSysClkRetVal == CY_SYSCLK_SUCCESS);

        /* Enable the clock path for bothe the FPDLINK */
        if(u8DispSelConfig == MAP_LVDS_CH_DUAL_CFG_0)
        {
            u32DispClkPllHz = (u32DispClkPllHz/2);
            Cy_SysClk_ClkHfSetSource(11 /*CY_SYSCLK_HFCLK_11*/, (cy_en_clkhf_in_sources_t)u8DispClkPath);
            Cy_SysClk_ClkHfSetSource(12 /*CY_SYSCLK_HFCLK_12*/, (cy_en_clkhf_in_sources_t)u8DispClkPath);
        }
        
        /* Configure PLL */
        cy_stc_pll_config_t stcPllCfg =
        {
            .inputFreq    = 16000000UL,
            .outputFreq   = u32DispClkPllHz,
            .outputMode   = CY_SYSCLK_FLLPLL_OUTPUT_AUTO,
        };
        enSysClkRetVal = Cy_SysClk_Pll400MConfigure(u8DispClkPath, &stcPllCfg);
        CY_ASSERT(enSysClkRetVal == CY_SYSCLK_SUCCESS);
        enSysClkRetVal = Cy_SysClk_Pll400MEnable(u8DispClkPath, 10000);
        CY_ASSERT(enSysClkRetVal == CY_SYSCLK_SUCCESS);
        Cy_SysClk_PllGetFrequency(u8DispClkPath);    
    }
    else
    {
        return CY_GFXENV_ERROR_BAD_PARAM;
    }
    
    /* Configure the single or dual display mode */
    if (bIsDispDualMode == true)
    {
        if(m_astcCustomDispPresets[enDispType].bUseFpd != false)
        {
            uint8_t u8MapIndex = MAP_INDEX_VESA;
            
            /* display engine 0 color mapping */
            VIDEOSS0_VIDEOIO0_DISENG00_TCON0->unMAPBIT3_0.u32Register   = m_aau32FpdMapping[0][u8MapIndex];
            VIDEOSS0_VIDEOIO0_DISENG00_TCON0->unMAPBIT7_4.u32Register   = m_aau32FpdMapping[1][u8MapIndex];
            VIDEOSS0_VIDEOIO0_DISENG00_TCON0->unMAPBIT11_8.u32Register  = m_aau32FpdMapping[2][u8MapIndex];
            VIDEOSS0_VIDEOIO0_DISENG00_TCON0->unMAPBIT15_12.u32Register = m_aau32FpdMapping[3][u8MapIndex];
            VIDEOSS0_VIDEOIO0_DISENG00_TCON0->unMAPBIT19_16.u32Register = m_aau32FpdMapping[4][u8MapIndex];
            VIDEOSS0_VIDEOIO0_DISENG00_TCON0->unMAPBIT23_20.u32Register = m_aau32FpdMapping[5][u8MapIndex];
            VIDEOSS0_VIDEOIO0_DISENG00_TCON0->unMAPBIT27_24.u32Register = m_aau32FpdMapping[6][u8MapIndex];
            
            /* display engine 0 color mapping */
            VIDEOSS0_VIDEOIO0_DISENG00_TCON0->unMAPBIT3_0_DUAL.u32Register      = m_aau32FpdMapping[0][u8MapIndex];
            VIDEOSS0_VIDEOIO0_DISENG00_TCON0->unMAPBIT7_4_DUAL.u32Register	= m_aau32FpdMapping[1][u8MapIndex];
            VIDEOSS0_VIDEOIO0_DISENG00_TCON0->unMAPBIT11_8_DUAL.u32Register     = m_aau32FpdMapping[2][u8MapIndex];
            VIDEOSS0_VIDEOIO0_DISENG00_TCON0->unMAPBIT15_12_DUAL.u32Register    = m_aau32FpdMapping[3][u8MapIndex];
            VIDEOSS0_VIDEOIO0_DISENG00_TCON0->unMAPBIT19_16_DUAL.u32Register    = m_aau32FpdMapping[4][u8MapIndex];
            VIDEOSS0_VIDEOIO0_DISENG00_TCON0->unMAPBIT23_20_DUAL.u32Register    = m_aau32FpdMapping[5][u8MapIndex];
            VIDEOSS0_VIDEOIO0_DISENG00_TCON0->unMAPBIT27_24_DUAL.u32Register    = m_aau32FpdMapping[6][u8MapIndex];
            
            /* Configure display engine 0 in dual fpd mode */
            VIDEOSS0_VIDEOIO0_DISENG00_DISENGCFG0->unCTL.stcField.u1DSPCLKDIVIDE = 0;
            VIDEOSS0_VIDEOIO0_DISENG00_TCON0->unTCON_CTRL.u32Register = 0;
            VIDEOSS0_VIDEOIO0_DISENG00_TCON0->unTCON_CTRL.stcField.u2CHANNELMODE = 1;
            //VIDEOSS0_VIDEOIO0_DISENG00_TCON0->unTCON_CTRL.stcField.u1BYPASS = 1;
            VIDEOSS0_VIDEOIO0_DISENG00_TCON0->unTCON_CTRL.stcField.u1BYPASS = 0;
            VIDEOSS0_VIDEOIO0_DISENG00_TCON0->unTCON_CTRL.stcField.u1ENLVDS = 1;
            
            /* Initialize FPD-LINK1 */
            if(Cy_Fpdlink_FastInit(FpdlinkDual01, (cy_fpdlink_en_pll_out_div_t) CLK_DIV_TO_REG_VAL(u8DispClkPllDiv)) != CY_FPDLINK_SUCCESS)
            {
                enRetVal = CY_GFXENV_ERROR;
            }
        }
    }
    else
    {
        if(m_astcCustomDispPresets[enDispType].bUseFpd != false)
        {
            uint8_t u8MapIndex = MAP_INDEX_VESA;
            VIDEOSS0_VIDEOIO0_DISENG10_TCON1->unMAPBIT3_0.u32Register   = m_aau32FpdMapping[0][u8MapIndex];
            VIDEOSS0_VIDEOIO0_DISENG10_TCON1->unMAPBIT7_4.u32Register   = m_aau32FpdMapping[1][u8MapIndex];
            VIDEOSS0_VIDEOIO0_DISENG10_TCON1->unMAPBIT11_8.u32Register  = m_aau32FpdMapping[2][u8MapIndex];
            VIDEOSS0_VIDEOIO0_DISENG10_TCON1->unMAPBIT15_12.u32Register = m_aau32FpdMapping[3][u8MapIndex];
            VIDEOSS0_VIDEOIO0_DISENG10_TCON1->unMAPBIT19_16.u32Register = m_aau32FpdMapping[4][u8MapIndex];
            VIDEOSS0_VIDEOIO0_DISENG10_TCON1->unMAPBIT23_20.u32Register = m_aau32FpdMapping[5][u8MapIndex];
            VIDEOSS0_VIDEOIO0_DISENG10_TCON1->unMAPBIT27_24.u32Register = m_aau32FpdMapping[6][u8MapIndex];

            VIDEOSS0_VIDEOIO0_DISENG10_DISENGCFG1->unCTL.stcField.u1DSPCLKDIVIDE = 1; // needed ???
            VIDEOSS0_VIDEOIO0_DISENG10_TCON1->unTCON_CTRL.u32Register = 0;
            VIDEOSS0_VIDEOIO0_DISENG10_TCON1->unTCON_CTRL.stcField.u1BYPASS = 1;
            VIDEOSS0_VIDEOIO0_DISENG10_TCON1->unTCON_CTRL.stcField.u1ENLVDS = 1;

            if(Cy_Fpdlink_FastInit(Fpdlink1, (cy_fpdlink_en_pll_out_div_t) CLK_DIV_TO_REG_VAL(u8DispClkPllDiv)) != CY_FPDLINK_SUCCESS)
            {
                enRetVal = CY_GFXENV_ERROR;
            }
        }

        VIDEOSS0_SUBSS0_VIDEOSSCFG->unCLKDSP1CFG.stcField.u2DIVVAL1       = CLK_DIV_TO_REG_VAL(u8DispClkPllDiv);
        VIDEOSS0_SUBSS0_VIDEOSSCFG->unCLKDSP1CFG.stcField.u1TTLCLKINV1    = 0;
        VIDEOSS0_VIDEOIO0_DISENG10_FRAMEGEN1->unHTCFG1.stcField.u14HACT   = m_astcCustomDispPresets[enDispType].u16HorizontalActive;
        VIDEOSS0_VIDEOIO0_DISENG10_FRAMEGEN1->unHTCFG1.stcField.u14HTOTAL = m_astcCustomDispPresets[enDispType].u16HorizontalTotal;
        VIDEOSS0_VIDEOIO0_DISENG10_FRAMEGEN1->unVTCFG1.stcField.u14VACT   = m_astcCustomDispPresets[enDispType].u16VerticalActive;
        VIDEOSS0_VIDEOIO0_DISENG10_FRAMEGEN1->unVTCFG1.stcField.u14VTOTAL = m_astcCustomDispPresets[enDispType].u16VerticalTotal;
        VIDEOSS0_VIDEOIO0_DISENG10_FRAMEGEN1->unFGENABLE.stcField.u1FGEN  = 1;
    }
    return enRetVal;
}


/*******************************************************************************
* Function Name: InitPortPins
********************************************************************************
*
* \brief  Initializes all port pins that shall be configured according to user
*         configuration.
*
* \param  pstcCfg : Pointer to to port pin config struct member of GFX Env
*                   config struct
*
*******************************************************************************/
static void InitPortPins(const cy_gfxenv_stc_init_portpins_t * pstcPortInitCfg)
{
    for(uint16_t u16Index = 0; u16Index < CY_GET_ARRAY_LEN(m_astcPortPinCfg); u16Index++)
    {
        const stc_portpin_cfg_t * pstcCurPortPin = &m_astcPortPinCfg[u16Index];

        /* Skip this loop iteration if the current port pin cfg belongs to a group that shall not be initialized*/
        switch(pstcCurPortPin->enGroup)
        {
            case Display0:
                if(pstcPortInitCfg->bInitDisplay0Ttl == false)
                {
                    continue;
                }
                break;
            case Display1:
                if(pstcPortInitCfg->bInitDisplay1Ttl == false)
                {
                    continue;
                }
                break;
            case Capture0:
                if(pstcPortInitCfg->bInitCapture0Ttl == false)
                {
                    continue;
                }
                break;
            case Smif0:
                if(pstcPortInitCfg->bInitSmif0 == false)
                {
                    continue;
                }
                break;
            case Smif1:
                if(pstcPortInitCfg->bInitSmif1 == false)
                {
                    continue;
                }
                break;
            case BlDisp0:
                if(pstcPortInitCfg->bInitBacklightDisp0 == false)
                {
                    continue;
                }
                break;
            case BlDisp1:
                if(pstcPortInitCfg->bInitBacklightDisp1 == false)
                {
                    continue;
                }
                break;
            case BlFpd0:
                if(pstcPortInitCfg->bInitBacklightFpdLink0 == false)
                {
                    continue;
                }
                break;
            case BlFpd1:
              #ifdef VIDEOSS0_FPDLINK1
                if(pstcPortInitCfg->bInitBacklightFpdLink1 == false)
                {
                    continue;
                }
                break;
              #else
                continue;
              #endif
            case Button:
                if(pstcPortInitCfg->bInitButtonGpios == false)
                {
                    continue;
                }
                break;
            default:
                break;
        }

        /* If more detailed port pin settings need to be made (e.g. input trip point, slew rate, drive strength)*/
        /* the implementation must be changed to use Cy_GPIO_Pin_Init API*/
        Cy_GPIO_Pin_FastInit( pstcCurPortPin->pstcPort,
                              pstcCurPortPin->u8Pin,
                              pstcCurPortPin->u8DriveMode,
                              pstcCurPortPin->u8GpioOutVal,
                              pstcCurPortPin->enMuxCfg      );

    }
}

/*******************************************************************************
* Function Name: Cy_SwTmr_GetTickCountUs
********************************************************************************
*
*  Summary:
*  Systick interrupt handler
*
*  Parameters:
*  None
*
*  Return:
*  None
*
**********************************************************************************/
uint64_t Cy_SwTmr_GetTickCountUs(void)
{
    return counterTick;
}
/*******************************************************************************
* Function Name: toggle_led_on_systick_handler
********************************************************************************
*
*  Summary:
*  Systick interrupt handler
*
*  Parameters:
*  None
*
*  Return:
*  None
*
**********************************************************************************/
void toggle_led_on_systick_handler(void)
{
    counterTick++;
}

/*******************************************************************************
* Function Name: Cy_PD_Enable
********************************************************************************
*
*  Summary:
*  Enable Graphics Subsystem Power Switch
*
*  Parameters:
*  None
*
*  Return:
*  None
*
**********************************************************************************/
void Cy_PD_Enable(void)
{
    const uint32_t pdCtl    = PD_BASE;
    const uint32_t pdStatus = PD_BASE + 0x10;

    *((volatile uint32_t *)pdCtl) |= PD_CTL_PWR_MODE_Msk;
    while ((*((volatile uint32_t *)pdStatus) & PD_STATUS_PWR_DONE_Msk) == 0);
    *(int*)(0x40A00000) = 0x80000000;
}


#if defined(__cplusplus)
}
#endif


/* [] END OF FILE */

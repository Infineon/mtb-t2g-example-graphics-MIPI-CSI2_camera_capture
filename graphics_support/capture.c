/**********************************************************************************************************************
 * \file capture.c
 * \copyright Copyright (C) Infineon Technologies AG 2025
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*******************************************************************************
**                      Include Section                                       **
*******************************************************************************/

#include <stdio.h>

#include "cygfx_driver_api.h"

#include "sm_util.h"
#include "ut_compatibility.h"
#include "ut_memman.h"
#include "cap_util.h"
#include "ut_config.h"
#include "ut_disp.h"
#include "pe_matrix.h"


#include "ut_disp_panels.h"

#include "cy_retarget_io.h"

#include "cy_device_headers.h"
#include "cy_mipicsi2.h"
#include "cy_mipi_sensor.h"
/*******************************************************************************
**                      Macros Definitions                                    **
*******************************************************************************/

#define NUM_CAP_SURFACES        (2)

/* Replacing all printf-s with SV logging function */
//#define printf Sv_SCB_UartNonSVPrintf

/*******************************************************************************
**                      Typedefs                                              **
*******************************************************************************/
#define FORMAT_RGB565               (1)
#define FORMAT_YUV422               (2)
#define PIXEL_FORMAT_SELECT			FORMAT_RGB565

CYGFX_U08   clockDivider[1];

#define USE_DUAL_DISPLAY        	(0u)
#define FRAMERATE_15HZ        		0
#define FRAMERATE_30HZ        		1
#define FRAMERATE_60HZ        		4
#define TIMING_640X480_60HZ         0
#define TIMING_1280X720_60HZ        1

#define CHOSEN_CAP_TIMING           TIMING_1280X720_60HZ 	// Capture and display Resolution
#define CHOSEN_DISP_TIMING          TIMING_1280X720_60HZ 	// Capture and display Resolution
#define CHOSEN_FRAME_RATE           FRAMERATE_60HZ			// Frame Rate selection


/*******************************************************************************
**                      Internal Functions Prototype                          **
*******************************************************************************/

/*******************************************************************************
**                      Global Variables                                      **
*******************************************************************************/

/* The current architecture strictly doesn't need any (extern) global variables 
   to be created in a test case */

/* Use them only if no alternate implementation is possible */

/*******************************************************************************
**                      Static Variables                                      **
*******************************************************************************/
static CYGFX_SYNC_OBJECT_S    s_syncCap;
static CYGFX_SYNC_OBJECT_S    s_syncWin;
static CYGFX_SURFACE          surfArray[NUM_CAP_SURFACES ] = {0};
static CYGFX_SURFACE_OBJECT_S surfReceived = {0};
static CYGFX_CAP_CTX          capCtx = NULL;
static CYGFX_WINDOW           winCapture = NULL;
CYGFX_U08                     clockDivider[1];
static void*                  CmdSeqBuffer = 0;

static CYGFX_DISP_TIMING_S     supported_timings[] =
{/*                     pixelClock,                                  Hact, Vact,      Htot,     Vtot,   Hsbp,    Vsbp, Hsync, Vsync, HtotMin, VtotMin,  HtotMax, VtotMax,           DCKInvertEnable,                   polEn,                   polHs,                   polVs,              pixInv */
    {/* "640x480@60" */ (CYGFX_FLOAT)(60 * 951 * 492) / 1000000.0f,   640,  480,       951,      492,    300,       7,    64,     4,     940,     488,      965,     494, CYGFX_DISP_DCK_INVERT_OFF, CYGFX_GEN_POLARITY_HIGH, CYGFX_GEN_POLARITY_HIGH, CYGFX_GEN_POLARITY_HIGH,  CYGFX_DISP_RGB_LOW},
	{/*"1280x720@60" */ (CYGFX_FLOAT)((60*(1650* 750))/1000000.0f),  1280,  720,      1650,      750,    260,      25,    40,     5,    1640,     746,     1660,     755, CYGFX_DISP_DCK_INVERT_OFF, CYGFX_GEN_POLARITY_HIGH, CYGFX_GEN_POLARITY_HIGH, CYGFX_GEN_POLARITY_HIGH,  CYGFX_DISP_RGB_LOW},
};

CYGFX_DISP_TCON_PROPERTIES_S    s_panel_XXX_800_480_tcon[] = 
{
    { 0x0408, 0x00000108}, /* CTRL (ENLVDS | BYPASS) */
    { 0x0410, 0x0506070a}, /* MapBit3_0   ( R3, R4, R5, G0)     */
    { 0x0414, 0x13020304}, /* MapBit7_4   ( B1, R0, R1, R2)     */
    { 0x0418, 0x0d0e0f12}, /* MapBit11_8  ( G3, G4, G5, B0)     */
    { 0x041c, 0x191a0b0c}, /* MapBit15_12 ( VSYNC, EN, G1, G2)  */
    { 0x0420, 0x15161718}, /* MapBit19_16 ( B3, B4, B5, HSYNC)  */
    { 0x0424, 0x10111b14}, /* MapBit23_20 ( B6, B7, RES, B2)    */
    { 0x0428, 0x00010809}, /* MapBit27_24 ( R6, R7, G6, G7)     */
};

static CYGFX_DISP_TIMING_S* captureTiming = &supported_timings[CHOSEN_CAP_TIMING];
static CYGFX_DISP_TIMING_S* DisplayTiming = &supported_timings[CHOSEN_DISP_TIMING];


/*******************************************************************************
**                      Internal Functions Defintions                         **
*******************************************************************************/
/*******************************************************************************
**                      ISR / Callback Definitions                            **
*******************************************************************************/
/*******************************************************************************
**                      Functions Defintions                                  **
*******************************************************************************/
/*******************************************************************************
* Function Name: BufferedCapture_MIPI_Init
****************************************************************************//**
*
* This function Initializes VIDEOSS and MIPI for buffered capture.
*
* \note Before calling this function, remember to initialize FPD-PLL and GFX drivers.
*
* \param LDisplayMode
* A pointer to the GFX 'mode' object with initialized timing parameters and display
* controller, that will be used to setup the Buffered capture from MIPI input. This 
* shall be initialized in the test case module where the other sub-modules 
* will also need it.
*
* \param LDisplayObj
* A pointer to the CYGFX_DISP object, that will be used for drivers calls in this 
* function. Only a NULL object needs to be passed to this API. The object shall be 
* initialized inside this function.
*
* \return
*    \retval CYGFX_OK(0) if there are no issues.
*            A non-zero value otherwise.
*
*******************************************************************************/
CYGFX_ERROR BufferedCapture_MIPI_Init()
{
    CYGFX_ERROR ret = CYGFX_OK;
    CYGFX_DISP LDisplayObj;

    CYGFX_CAP_PROPERTIES_S          capProperties = CYGFX_CAP_PROPERTIES_INITIALIZER;
    CYGFX_DISP_PROPERTIES_S         mode = CYGFX_DISP_PROPERTIES_INITIALIZER;
    CYGFX_DISP_WINDOW_PROPERTIES_S  windowProp = CYGFX_DISP_WINDOW_PROPERTIES_INITIALIZER;
    CYGFX_SYSINIT_INFO_S            InitInfo = CYGFX_SYS_INIT_INITIALIZER;
    CYGFX_U32                       CmdSeqSize =  64 * 1024;
    
    mode.timing = *DisplayTiming;
    mode.outputController = CYGFX_DISP_CONTROLLER_1;

    /* Enable the PLL in main, just check here */
    UTIL_SUCCESS(ret, utDispGetPll(DisplayTiming->pixelClock, CYGFX_DISP_MODE_SINGLE_SCREEN, &clockDivider[0], &InitInfo.PllDsp1));
/*    printf("\n\r Active PLL1: %lu, Clock Divider: %u, Pixel Clock: %f", InitInfo.PllDsp1, clockDivider[0], DisplayTiming->pixelClock);*/
    InitInfo.PllDsp0 = 0U;

    mode.pTconProps = s_panel_XXX_800_480.pTconProps;
    mode.countTconProps = s_panel_XXX_800_480.countTconProps;

    /* Driver initialization */
    UTIL_SUCCESS(ret, utDispGetPll(DisplayTiming->pixelClock, CYGFX_DISP_MODE_SINGLE_SCREEN, &clockDivider[0], &InitInfo.PllDsp1)); 
/*    printf("\n\r Active PLL0: %lu", InitInfo.PllDsp0);*/
/*    printf("\n\r Active PLL1: %lu", InitInfo.PllDsp1);*/
    UTIL_SUCCESS(ret, CyGfx_SysInitializeDriver(&InitInfo));
    if (ret != CYGFX_OK)
    {
        printf("ERROR: Received error 0x%08lx from CyGfx_SysInitializeDriver(). Aborting.\n", ret);
        return ret;
    }
    UTIL_SUCCESS(ret, utMmanReset());

    /* Allocate video memory as buffer for command sequencer */
    CmdSeqBuffer = utVideoAlloc( CmdSeqSize, 32, 0 );
    if ( NULL == CmdSeqBuffer )
    {
        ret = CYGFX_ERR;
    }

    /* Hand allocated memory over to command sequencer */
    UTIL_SUCCESS(ret, CyGfx_BeSetTaskInstructionBuffer(CYGFX_BE_TASK_MEM_PRIO_1, CmdSeqBuffer, CmdSeqSize));
    
    /* MIPI-CSI configuration */
    cy_mipicsi2_stc_cfg_t    mipi_config = 
    {
        .bAutoPowerDown         = true,
        .bContClkMode           = true,
        .bHighSpeed             = true,
        .u4FlushCount           = 3,
        .u32BitrateBps          = 0,
        .u32EscClkFreqHz        = 0,
        .u32CaptureResolution   = CHOSEN_CAP_TIMING,
        .u32CaptureFrameRate    = CHOSEN_FRAME_RATE,
        .enEscClk               = Mipicsi2EscapeClockClkSys,
        .enLaneCount            = Mipicsi2LaneCount2,
        .enCalibration          = Mipicsi2CalibAutomatic,
        .unPayloadDisable       = {(cy_mipicsi2_stc_payload_disable_t){.u1Blank= 1,}}
    };

    /* MIPI sensor configuration */
	cy_mipisensor_stc_cfg_t mipisensor_config =
    {
        #if(PIXEL_FORMAT_SELECT == FORMAT_YUV422)
            .u16FrameFormat	 = CY_MIPI_FORMAT_YUV422,
        #elif(PIXEL_FORMAT_SELECT == FORMAT_RGB565)
            .u16FrameFormat	 = CY_MIPI_FORMAT_R5G6B5,
        #endif
        .u16Framerate        = CHOSEN_FRAME_RATE,
        .u16Resolution       = CHOSEN_CAP_TIMING,
    };

    /* De-initialize mipi sensor contrl path */
    Cy_Mipi_Image_Sensor_DeInit();
    printf("\n\r Initializing mipi sensor.");

    /* Initialize mipi sensor interface */
    ret = Cy_Mipi_Image_Sensor_Init(&mipisensor_config);
    if (ret != 0)
    {
        printf("\n\r Error in MIPI init.");
    }
    
    /* Set capture source to MIPI CSI Input */
    VIDEOSS0_SUBSS0_VIDEOSSCFG->unCAP0CFG.stcField.u2CAP0SRC = 0x01; 

    /* Initialize MIPI and Enable all interrupts */
    Cy_Mipicsi2_Init(VIDEOSS0_MIPICSI0, &mipi_config);
    Cy_Mipicsi2_SetInterruptMask(VIDEOSS0_MIPICSI0, Mipicsi2IrqErrorCrc, true);
    Cy_Mipicsi2_SetInterruptMask(VIDEOSS0_MIPICSI0, Mipicsi2IrqErrorEccSingle, true);
    Cy_Mipicsi2_SetInterruptMask(VIDEOSS0_MIPICSI0, Mipicsi2IrqErrorEccDouble, true);
    Cy_Mipicsi2_SetInterruptMask(VIDEOSS0_MIPICSI0, Mipicsi2IrqStatusUlpsActiveChange, true);
    Cy_Mipicsi2_SetInterruptMask(VIDEOSS0_MIPICSI0, Mipicsi2IrqStatusUlpsMarkActiveChange, true);

    /* Set capture properties as per input parameters */
    printf("\n\r Configuring capture engine.");
    capProperties.Hact       	  = captureTiming->Hact;
    capProperties.Vact       	  = captureTiming->Vact;
    capProperties.Htot       	  = captureTiming->Htot;
    capProperties.Vtot       	  = captureTiming->Vtot;
    capProperties.pixelClock 	  = captureTiming->pixelClock;
    capProperties.polEn           = ((captureTiming->polEn & CYGFX_GEN_POLARITY_HIGH) == CYGFX_GEN_POLARITY_HIGH) ? CYGFX_GEN_POLARITY_LOW : CYGFX_GEN_POLARITY_HIGH;
    capProperties.polHs           = captureTiming->polHs;
    capProperties.polVs           = captureTiming->polVs;
#if (PIXEL_FORMAT_SELECT == FORMAT_RGB565)
    capProperties.format     	  = CYGFX_CAP_VIDEO_FORMAT_PARALLEL_RGB;
#else
    capProperties.format          = CYGFX_CAP_VIDEO_FORMAT_PARALLEL_YUV422;
#endif /* PIXEL_FORMAT_SELECT */
    capProperties.directCapEnable = CYGFX_CAP_DIRECT_CAPTURE_OFF;
    capProperties.inputInterface  = CYGFX_CAP_INTERFACE_CSI;
   

    /* Open Capture Unit, Set inputFormat to YUV422 */
    UTIL_SUCCESS(ret,  CyGfx_CapOpen(CYGFX_CAP_UNIT_0, &capProperties, &capCtx));
#if (PIXEL_FORMAT_SELECT == FORMAT_RGB565)
    UTIL_SUCCESS(ret,  CyGfx_CapSetAttribute( capCtx, CYGFX_CAP_ATTR_COLORBITS,  0x05060500U));
    UTIL_SUCCESS(ret,  CyGfx_CapSetAttribute( capCtx, CYGFX_CAP_ATTR_COLORSHIFT, 0x0B050000U));
#else
    UTIL_SUCCESS(ret,  CyGfx_CapSetAttribute( capCtx, CYGFX_CAP_ATTR_COLORBITS,  0x08080808U));
    UTIL_SUCCESS(ret,  CyGfx_CapSetAttribute( capCtx, CYGFX_CAP_ATTR_COLORSHIFT, 0x08000000U));
#endif /* PIXEL_FORMAT_SELECT */
/*    printf("\n\r Configured capture unit -- %lx", ret);*/

    /* Open display */
    UTIL_SUCCESS(ret,  CyGfx_DispOpenDisplay( &mode, &LDisplayObj, 0));
/*    printf("\n\r Opening display controller : %d.", mode.outputController);*/
    UTIL_SUCCESS(ret, utDispEnableFpdLink(clockDivider[0], mode.displayMode, Fpdlink1)); //FpdLink0
/*    printf("\n\r Enabling fpd link display : %d.", Fpdlink1);*/
   
    /* Create capture surfaces */
    UTIL_SUCCESS(ret, utSmGenSurfaceObjects(NUM_CAP_SURFACES, &surfArray[0])); 
    for (uint32_t i = 0; i < NUM_CAP_SURFACES; i++)
    {
#if (PIXEL_FORMAT_SELECT == FORMAT_RGB565)
        UTIL_SUCCESS(ret, utSurfCreateBuffer(surfArray[i], captureTiming->Hact, captureTiming->Vact, CYGFX_SM_FORMAT_R5G6B5));
#else
        UTIL_SUCCESS(ret, utSurfCreateBuffer(surfArray[i], captureTiming->Hact, captureTiming->Vact, CYGFX_SM_FORMAT_YVYU422));
#endif /* PIXEL_FORMAT_SELECT */        
    }

    /* Set resolution mipi sensor interface */
    CY_ASSERT(Cy_Mipi_Image_Sensor_Wakeup() == CY_MIPI_SENSOR_SUCCESS);
    printf("\n\r Mipi sensor wakeup.");

    UTIL_SUCCESS(ret, CyGfx_CapAssignSurfaceArray(capCtx, surfArray, NUM_CAP_SURFACES));
    UTIL_SUCCESS(ret, CyGfx_CapCommit(capCtx));
    printf("\n\r*** Start capture-to-surface with %d buffers ***\n", NUM_CAP_SURFACES);
    UTIL_SUCCESS(ret, CyGfx_SyncReset(&s_syncCap));
    UTIL_SUCCESS(ret, CyGfx_CapGetSync(capCtx, &s_syncCap));

    /* Wait until it happens */
    while(CyGfx_SyncWaitSync(&s_syncCap, 0) == CYGFX_ERP_ERR_SYNC_TIMEOUT)
    {
        __NOP();
    }

    windowProp.topLeftX = 0;
    windowProp.topLeftY = 0;
    windowProp.width    = captureTiming->Hact;
    windowProp.height   = captureTiming->Vact;
    windowProp.layerId  = CYGFX_DISP_LAYER_1;
    windowProp.features = CYGFX_DISP_FEATURE_YUV1BUFF;
    UTIL_SUCCESS(ret, CyGfx_DispWinCreate(LDisplayObj, &windowProp, &winCapture)); 
	printf("\n\r GfxDrvExampleInit ret -- %lx.", ret);

    return ret;
}

/*******************************************************************************
* Function Name: BufferedCapture_MIPI_DrawStroke
****************************************************************************//**
*
* This function pulls the first surface buffer onto the display. 
*
* This doesn't necessarily have to be called continuously in a loop, as the name 
* suggests. Once the first buffer is pulled, the rest keeps flowing.
*
* The API shall be renamed once the above assumption is confirmed.
*
* \note Before calling this function, remember to call BufferedCapture_MIPI_Init()
* at least once.
*
* \param None
* None
*
* \return
*    \retval CYGFX_OK(0) if there are no issues.
*            A non-zero value otherwise.
*
*******************************************************************************/
CYGFX_ERROR BufferedCapture_MIPI_DrawStroke(void)
{
    CYGFX_ERROR ret = CYGFX_OK;

    if (CYGFX_ERP_ERR_SYNC_TIMEOUT == CyGfx_SyncWaitSync(&s_syncWin, 0))
    {
        /* Return if window is still busy */ 
        return CYGFX_OK;
    }
   
    /* Retrieve the last captured frame. */
    UTIL_SUCCESS(ret, CyGfx_CapGetSurface(capCtx, &surfReceived));
    UTIL_SUCCESS(ret, CyGfx_CapCommit(capCtx));

    /* Let's show it on the screen */
    UTIL_SUCCESS(ret, CyGfx_WinSetSurface(winCapture, CYGFX_DISP_BUFF_TARGET_COLOR_BUFF, &surfReceived));
    UTIL_SUCCESS(ret, CyGfx_WinCommit(winCapture));
	
    /* Get a sync object to know when the swap is finished */
    UTIL_SUCCESS(ret, CyGfx_WinGetSync(winCapture, &s_syncWin));
    
     /* Wait until it happens */
    while(CyGfx_SyncWaitSync(&s_syncWin, 0) == CYGFX_ERP_ERR_SYNC_TIMEOUT)
    {
        __NOP();
    }
    return ret;
}

/*******************************************************************************
* Function Name: BufferedCapture_MIPI_Cleanup
****************************************************************************//**
*
* Cleans up all windows, surfaces and capture context created for Buffered Capture
* from MIPI input.
*
* \note The cleanup of the display object is outside the scope of this module. 
* That has to be taken care by the test case (or) higher level modules.
*
* \param None
* None
*
* \return
*    \retval None
*
*******************************************************************************/
void BufferedCapture_MIPI_Cleanup(void)
{
    if(winCapture != NULL)
    {
        CyGfx_WinDestroy(winCapture);
        winCapture = NULL;
    }

    /* Delete surfaces */
    for (uint32_t i=0; i<NUM_CAP_SURFACES; i++)
    {
        if (surfArray[i])
        {
            utSurfDeleteBuffer(surfArray[i]);
        }
    }  

    if(capCtx != NULL)
    {
        CyGfx_CapClose(capCtx);
        capCtx = NULL;
    }
}


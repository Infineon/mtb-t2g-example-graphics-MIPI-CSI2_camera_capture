/**********************************************************************************************************************
 * \file main.c
 * \copyright Copyright (C) Infineon Technologies AG 2025
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "cy_pdl.h"
#include "cybsp.h"
#include "cygfx_defines.h"
#include "cygfx_basetypes.h"
#include "cy_fpdlink.h"
#include "cy_gfx_env.h"
#include "cmsis_compiler.h"
#include "cy_lvds_hdmi.h"
#include <stdio.h>
#include "cy_retarget_io.h"
#include "cy_mipicsi2.h"

/*******************************************************************************
* Macros
********************************************************************************/ 
#define LED_TOGGLE_TIMER_ID             (1)
/* Select the display */
#define CEA_1280x720P_60_HDMI           (1)
#define SELECT_EMBEDDED_DISPLAY         CEA_1280x720P_60_HDMI
#define DISP1_TYPE                      CY_GFXENV_DISP_TYPE_1280_720_60_CEA_VESA

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
/* VideoSS Interrupts Config */
const cy_stc_sysint_t irq_cfg[]
    = {{.intrSrc = ((NvicMux3_IRQn << CY_SYSINT_INTRSRC_MUXIRQ_SHIFT) | videoss_0_interrupt_gfx2d_IRQn),
        .intrPriority = 3},
       {.intrSrc = ((NvicMux3_IRQn << CY_SYSINT_INTRSRC_MUXIRQ_SHIFT) | videoss_0_interrupt_mipicsi_IRQn),
        .intrPriority = 3},
       {.intrSrc = ((NvicMux3_IRQn << CY_SYSINT_INTRSRC_MUXIRQ_SHIFT) | videoss_0_interrupt_videoio0_IRQn),
        .intrPriority = 3},
       {.intrSrc = ((NvicMux3_IRQn << CY_SYSINT_INTRSRC_MUXIRQ_SHIFT) | videoss_0_interrupt_videoio1_IRQn),
        .intrPriority = 3}
      };

uint8_t clearConsoleScreen[] = "\033[2J\033[1;1H";
static const cy_gfxenv_stc_cfg_t m_stcGfxEnvCfg = 
{
    .bInitSwTimer         = true,
    .bInitSemihosting     = true,
    .pstcInitPortPins     = &(cy_gfxenv_stc_init_portpins_t)
                            {
                                .bInitDisplay0Ttl     = false, /* usually the FPD-Link is used on silicon */
                            #if (SELECT_EMBEDDED_DISPLAY == CEA_1280x720P_60_HDMI)
                                .bInitDisplay1Ttl     = false, /* usually the FPD-Link is used on silicon */
                            #else
                                .bInitDisplay1Ttl     = true,  /* usually the FPD-Link is used on silicon */
                            #endif /* SELECT_EMBEDDED_DISPLAY */
                                .bInitCapture0Ttl     = false,
                                .bInitSmif0           = false,
                                .bInitSmif1           = false,
                                .bInitBacklightDisp0  = false,
                                .bInitBacklightDisp1  = false,
                                .bInitButtonGpios     = false,
                            },
    .pstcInitExtMem       = NULL,
    .pstcInitButtons      = NULL
};
static cy_stc_hdmi_trx_config_t hdmiLvdsConfig =
{
    .colorBits      = CY_LVDS_LINK_8BIT,
    .encodeFormat   = CY_LVDS_FORMAT_VESA,
    .colorFormat    = CY_HDMI_COLOR_RGB444,
    .videoType      = CY_HDMI_1280x720p60,
    .singleOrDual   = CY_LVDS_LINK_SINGLE,
};
/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
static void MipiIrqCallback(void);
static void ConfigureVideoSSInterrupt(void);
static void SDL_VideoSSInterruptHandler(void);
extern void CyGfx_kInterruptHandlerVideoio0(void);
extern void CyGfx_kInterruptHandlerVideoio1(void);
extern void CyGfx_kInterruptHandlerGfx2d(void);
extern CYGFX_ERROR BufferedCapture_MIPI_Init(void);
extern CYGFX_ERROR BufferedCapture_MIPI_DrawStroke(void);
extern void BufferedCapture_MIPI_Cleanup(void);
/**********************************************************************************************************************
 * Function Name: main
 * Summary:
 *  This main achieve the systick timer interrupt function. Toggle user led when generate
 *  the systick interrupt up to 10 times.
 *
 * Parameters:
 *  none
 * Return:
 *  int
 **********************************************************************************************************************
 */
int main(void)
{
    CYGFX_ERROR ret;
    cy_gfxenv_en_result_t result;
    cy_en_hdmi_trx_status_t status;

    cy_rslt_t bsp_result;

    /* Initialize the device and board peripherals */
    bsp_result = cybsp_init();
    if (bsp_result != CY_RSLT_SUCCESS)
    {
        CY_ASSERT(0);
    }
    
    __enable_irq();
    /* Enable Graphics Subsystem Power Switch */
    Cy_PD_Enable(); 
    SCB_DisableICache();
    SCB_DisableDCache(); /* Disables, cleans and invalidates data cache */

    /* Configuring video sub-system interrupts */
    ConfigureVideoSSInterrupt();
    /* Don't use printf before this point, as retargetIO is initialized here*/
    result = Cy_GfxEnv_Init(&m_stcGfxEnvCfg);
    printf("%s", clearConsoleScreen);
    printf("\r\n__________________________________________________________________________\r\n*\t\t"\
            "Graphics_MIPI-CSI2_Camera_Capture\r\n*\t"\
            "UART Terminal Settings: Baud Rate - 115200 bps, 8N1\r\n*"\
            "\r\n__________________________________________________________________________\r\n\n");


    CY_ASSERT(result == CY_GFXENV_SUCCESS);
    printf("\n\r CM7_0 Initialization finished...\n");

    /* Application Entry Point */
    /* Draw something. */
    ret = BufferedCapture_MIPI_Init();

    /* Application Entry Point */
    result = Cy_GfxEnv_EnableHdmiTestImage(DISP1_TYPE);

    /* Initialize the HDMI transceiver */
    Cy_HDMI_Transceiver_Init(hdmiLvdsConfig);
    for(uint8_t i=0; i<8; i++)
    {
        Cy_HDMI_Transceiver_DeviceLoop();
    }


    for (;;)
    {
        /* Check for HDMI event for hotplug in */
        status = Cy_HDMI_Transceiver_DeviceLoop();
        if(status == CY_HDMI_TRX_BAD_PARAM){
            printf("\n\r HDMI_Err...\n");
            break;
        }
        ret = BufferedCapture_MIPI_DrawStroke();

        Cy_GPIO_Inv(CYBSP_USER_LED_PORT, CYBSP_USER_LED_PIN);
        Cy_SysLib_Delay(1);
    }

    printf("\nTerminated.\n");
    if (ret != CYGFX_OK || status != CY_HDMI_TRX_SUCCESS)
    {
        printf("HDMI_Status code: %x\n", status);
        printf("MIPI_Return code: %lx\n", ret);
    }

    BufferedCapture_MIPI_Cleanup();

    for (;;)
    {
        Cy_GPIO_Inv(CYBSP_USER_LED_PORT, CYBSP_USER_LED_PIN);
        Cy_SysLib_Delay(10);
    }
}

/*****************************************************************************
 ** \brief Callback function for MIPI Input
 **
 ** \return none
 *****************************************************************************/
static void MipiIrqCallback(void)
{
/*    uint32_t CRCStatus, ECCSingleStatus, ECCDoubleStatus, ULPSActiveStatus, ULPSMarkActiveStatus;*/
#if 0 
/*this is just for your information, when you want to check status please enable the following.*/
    CRCStatus = Cy_Mipicsi2_GetInterruptStatus(VIDEOSS0_MIPICSI0, Mipicsi2IrqErrorCrc);
    ECCSingleStatus = Cy_Mipicsi2_GetInterruptStatus(VIDEOSS0_MIPICSI0, Mipicsi2IrqErrorEccSingle);
    ECCDoubleStatus = Cy_Mipicsi2_GetInterruptStatus(VIDEOSS0_MIPICSI0, Mipicsi2IrqErrorEccDouble);
    ULPSActiveStatus = Cy_Mipicsi2_GetInterruptStatus(VIDEOSS0_MIPICSI0, Mipicsi2IrqStatusUlpsActiveChange);
    ULPSMarkActiveStatus = Cy_Mipicsi2_GetInterruptStatus(VIDEOSS0_MIPICSI0, Mipicsi2IrqStatusUlpsMarkActiveChange);
#endif
    Cy_Mipicsi2_GetInterruptStatus(VIDEOSS0_MIPICSI0, Mipicsi2IrqErrorCrc);
    Cy_Mipicsi2_GetInterruptStatus(VIDEOSS0_MIPICSI0, Mipicsi2IrqErrorEccSingle);
    Cy_Mipicsi2_GetInterruptStatus(VIDEOSS0_MIPICSI0, Mipicsi2IrqErrorEccDouble);
    Cy_Mipicsi2_GetInterruptStatus(VIDEOSS0_MIPICSI0, Mipicsi2IrqStatusUlpsActiveChange);
    Cy_Mipicsi2_GetInterruptStatus(VIDEOSS0_MIPICSI0, Mipicsi2IrqStatusUlpsMarkActiveChange);

/*  printf("MipiIrq CRC: %lx\n", CRCStatus);
    printf("MipiIrq CRC: %lx\n", ECCSingleStatus);
    printf("MipiIrq CRC: %lx\n", ECCDoubleStatus);
    printf("MipiIrq CRC: %lx\n", ULPSMarkActiveStatus);*/
}

/*****************************************************************************
 ** \brief Configuring VideoSS interrupt
 **
 ** \return none
 *****************************************************************************/
static void ConfigureVideoSSInterrupt(void)
{
    /* Initialize VideoSS interrupts */
    Cy_SysInt_Init(&irq_cfg[0], (cy_israddress) SDL_VideoSSInterruptHandler); /* GFX_2D */
    Cy_SysInt_Init(&irq_cfg[1], (cy_israddress) SDL_VideoSSInterruptHandler); /* MIPI */
    Cy_SysInt_Init(&irq_cfg[2], (cy_israddress) SDL_VideoSSInterruptHandler); /* VideoIO0 */
    Cy_SysInt_Init(&irq_cfg[3], (cy_israddress) SDL_VideoSSInterruptHandler); /* VideoIO1 */

    /* Set Prio/Enable IRQ */
    NVIC_ClearPendingIRQ((IRQn_Type) NvicMux3_IRQn);
    NVIC_EnableIRQ((IRQn_Type) NvicMux3_IRQn);
}

/*****************************************************************************
 ** \brief UserISR on VideoSS related
 **
 ** \return none
 *****************************************************************************/
static void SDL_VideoSSInterruptHandler(void)
{ /* Call VIDEOSS Interrupt handlers */
    CyGfx_kInterruptHandlerVideoio0();
    CyGfx_kInterruptHandlerVideoio1();
    CyGfx_kInterruptHandlerGfx2d();
	MipiIrqCallback();
    /* Clear Interrupt flag */
    NVIC_ClearPendingIRQ((IRQn_Type) NvicMux3_IRQn);
}

/* [] END OF FILE */
